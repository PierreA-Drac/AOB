% Preamble
% =============================================================================

% Class of the document.
\documentclass[12pt,a4paper]{article}
% article : short article.
% report  : mid-length report.
% book    : book or thesis redaction.

% Paragraph skip length (default to 0).
\setlength{\parskip}{1ex}

% Packages
% =============================================================================

% Encoding
% -----------------------------------------------------------------------------

% Babel.
\usepackage[french]{babel}
% FontEnc.
\usepackage[T1]{fontenc}
% InputEnc.
\usepackage[utf8]{inputenc}

% Define \escapeus command to escape underscores.
\makeatletter
\DeclareRobustCommand*{\escapeus}[1]{
    \begingroup\@activeus\scantokens{#1\endinput}\endgroup}
\begingroup\lccode`\~=`\_\relax
    \lowercase{\endgroup\def\@activeus{\catcode`\_=\active \let~\_}}
\makeatother

% Text
% -----------------------------------------------------------------------------

% Acronym.
\usepackage{acronym}
% CsQuote.
\usepackage[style=french,french=guillemets]{csquotes}
% Enumerate.
\usepackage{enumerate}
% HyperRef.
\usepackage[hyperfootnotes=false,hidelinks]{hyperref}
% URL.
\usepackage{url}

% Algorithms
% -----------------------------------------------------------------------------

% Algorithm2E.
\usepackage[french,onelanguage,linesnumbered,ruled,vlined,commentsnumbered]{algorithm2e}

% Source code
% -----------------------------------------------------------------------------

% Listings.
\usepackage{listings}
% Minted.
\usepackage{minted}
% Caption.
\usepackage{caption}
\newenvironment{code}{\captionsetup{type=listing}}{}

% Files
% -----------------------------------------------------------------------------

% FancyVRB.
\usepackage{fancyvrb}
% Redefine \VerbatimInput.
\RecustomVerbatimCommand{\VerbatimInput}{VerbatimInput}
{
    fontsize=\footnotesize,
    frame=lines,         % Top and bottom rule only.
    framesep=1.5em,      % Separation between frame and text.
    rulecolor=\color{red!50!green!50!blue!50!},
    labelposition=topline,
    commandchars=\|\(\), % Escape character and argument delimiters for commands within the verbatim.
    commentchar=*        % Comment character.
}

% Figures
% -----------------------------------------------------------------------------

% GraphicX.
\usepackage{graphicx}
% SVG.
\usepackage{svg}
% WrapFig.
\usepackage{wrapfig}

% Charts
% -----------------------------------------------------------------------------

% PGFPLots
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usepgfplotslibrary{units}

% Mathematics
% -----------------------------------------------------------------------------

% AmsFonts.
\usepackage{amsfonts}
% AmsMath.
\usepackage{amsmath}
% AmsText.
\usepackage{amstext}
% AmsThm.
\usepackage{amsthm}
\newtheorem{prr}{Propriété}
\newtheorem{pro}{Proposition}
\newtheorem{thm}{Théorème}
\newtheorem{lem}{Lemme}
% NumPrint.
\usepackage{numprint}

% Physics
% -----------------------------------------------------------------------------

% Physics.
\usepackage{physics}

% Presentation
% -----------------------------------------------------------------------------

% XColor.
\usepackage{xcolor}

% References
% -----------------------------------------------------------------------------

% CleveRef.
\usepackage{cleveref}

% Structure.
% -----------------------------------------------------------------------------

% Geometry.
\usepackage{geometry}
% PDFLScape.
\usepackage{pdflscape}
% MultiCol.
\usepackage{multicol}
% TitleSec.
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage} % Use a page break before new sections.
% VMargin.
\usepackage{vmargin}
% FootMisc.
\usepackage[bottom]{footmisc}

% Symbols
% -----------------------------------------------------------------------------

% SIUnitX.
\usepackage{siunitx}

% Table
% -----------------------------------------------------------------------------

% Array.
\usepackage{array}
% BookTabs.
\usepackage{booktabs}
% CSVSimple.
\usepackage{csvsimple}

% Document
% =============================================================================

\begin{document}

\title{Analyse de performance et optimisation de code}
\author{Pierre AYOUB}

\maketitle

\begin{figure}[b]
    \centering
    \includegraphics[scale=0.3]{figures/isty.jpg}
\end{figure}

\newpage
\begin{abstract}

La simulation numérique est un procédé informatique visant à modéliser un
phénomène par ordinateur, s’agissant le plus souvent d’un phénomène
physique. Cette modélisation prend forme par des systèmes d’équations
décrivant l’état du système physique représenté à chaque instant. De
nombreux domaines scientifiques convergent vers la simulation
informatique, tel que certaines branches de la physique, de l’analyse
et de l’optimisation mathématique, ou encore le calcul haute
performance en informatique. Enfin, la simulation trouve naturellement
de nombreuses applications concernant des sujets variés, tel que la
simulation du climat et des évènements météorologiques, la simulation
d’essais nucléaires, de l’effet d’un médicament sur un corps, ou encore
des astres et de l’univers. Ce rapport s’articulera donc autour de la
simulation de fumée, phénomène impliquant les lois de la mécanique des
fluides. Notre travail portera sur l’aspect du calcul haute performance
de cette simulation.

\end{abstract}

\tableofcontents

\section{Introduction}
\label{sec.intro}

Le projet que nous vous présentons aujourd’hui consiste à analyser puis,
grâce à nos mesures, optimiser un code de simulation numérique. Ce dernier
nous offre une interface graphique permettant d’ajouter de la fumée dans un
espace confiné et, ainsi, d’en observer le comportement. Nous pouvons
influencer la quantité de fumée et sa vélocité dans l’espace. De plus,
l’application nous donne le contrôle sur la résolution de la simulation,
cela revient à dire sur sa précision, qui détermine principalement la
performance du programme.

Le déroulement du projet s’est effectué en plusieurs étapes distinctes :
\begin{description}
    \item[Analyse du code] Cette phase consiste à analyser le programme
        d’un point de vue mathématique et informatique. De cette première
        approche, il s’agira de comprendre les opérations du programme sur
        les équations qui régissent le système physique. De l’autre
        approche, il convient d’étudier l’architecture logicielle de
        l’application, ainsi que les choix mis en œuvres afin d’implémenter
        le ou les algorithmes nécessaires.
    \item[Protocole expérimental] Une fois l’analyse effectuée, nous
        pouvons en déduire le moyen le plus adapté afin de mesurer les
        performances de notre implémentation. Nous allons donc mettre en
        avant les critères théoriques à atteindre dans nos mesures, puis
        nous exposerons la manière dont nous avons mis ceci en pratique.
    \item[Optimisations et mesures] Grâce au protocole mis en place, nous
        pouvons quantifier la performance du programme. De ce fait, nous serons
        en mesure d’expérimenter différentes techniques d’optimisation sur le
        programme et d’en calculer l’accélération.
\end{description}

\section{Analyse du code}
\label{sec.analyze}

% \VerbatimInput[label=\fbox{\color{red!85!green!85!blue!85!}fluid.cflow},]{figures/callgraph/fluid.cflow}

L'analyse du code est la première étape à effectuer afin d'optimiser un code. Il
s'agit d'identifier les différentes sections et fonctions qui pourraient être
critiques, ainsi que de comprendre mathématiquement quelles fonctions
remplissent quels rôles.

L’interface du programme et l’interaction avec l’utilisateur est géré par les
fichiers \enquote{demo.html}, \enquote{FluidSolver.java} et
\enquote{WebStart.java}. À priori, ces fichiers nous importe peu dans notre
processus d’analyse et d’optimisation. Le cœur de la simulation se déroule dans
le fichier \enquote{fluid.c}, dans lequel se situe les fonctions de calcul des
phénomènes physique.

\begin{figure}[h]
    \centering
    {
        \scriptsize
        \escapeus{\includesvg[scale=0.5]{figures/callgraph/fluid.svg}}
    }
    \caption{Graphe d'appel du fichier \textit{fluid.c}}
    \label{fig.analyze.callgraph}
\end{figure}

Avant d'observer et d’analyser attentivement le code du fichier
\enquote{fluid.c}, nous avons utilisé \textbf{Cflow} afin d’obtenir un graphe
d’appel pour avoir une vue d’ensemble et observer les liens entre les fonctions.
Le résultat est présenté dans la figure~\ref{fig.analyze.callgraph}. Nous
décrivons ici les fonctions principales. On remarque très rapidement les deux
points d’entrés du programme : \enquote{c\_densitySolver()} et
\enquote{c\_velocitySolver()}. Ces deux fonctions sont utilisées conjointement
pour assurer les deux fonctionnalités de notre simulation : la première permet
de calculer la position d’une particule de fumée ajouté par la souris, la
deuxième permet de calculer leur déplacement en fonction des différentes
vélocités dans l’espace. Nous observons ensuite deux fonctions qui sont ici pour
assurer des opérations physique : \enquote{project()} et \enquote{diffuse()}. Le
nom laisse sous entendre que la première permet de faire une projection (des
coordonnées d’un système à un autre ?) et la seconde permet de diffuser (une
particule dans l’espace ?), mais nos connaissances en mécanique des fluides nous
arrêtent ici pour les suppositions. Cependant, il est intéressant d’observer que
ces deux fonctions font appel à une nouvelle fonction :
\enquote{linearSolver()}. Cette fonction, comme le nom le laisse entendre, est
le cœur de calcul de l’application : elle permet de résoudre un système
d’équation linéaire. Il ne fait aucune doute que c’est dans cette fonction que
de nombreuses optimisations seront possibles ! Enfin, on observe quelques autres
fonctions de physique (\enquote{vorticityConfinement()}, \enquote{advect()},
\enquote{buoyancy()}) ou des fonctions de mathématiques (\enquote{sqrt()},
\enquote{abs()}) qui gravitent autour des fonctions précédemment décrites.
Enfin, une fonction semble être appelée par quasiment toutes les autres de
manière récursive : la fonction \enquote{build\_index()} . Cette fonction, très
courte, permet de passer d’un couple de coordonnées $(i, j)$ identifiant une
donnée à un offset correspondant à son emplacement mémoire par rapport à la base
de la matrice. Cette fonction, présente à de nombreux endroits dans le code,
devrait aussi avoir droit à une attention particulière.

\section{Protocole expérimental}
\label{sec.prot}

La mise en place d’un protocole expérimental de mesure est une étape nécessaire
et cruciale dans tout optimisation de code. D’une part, le but de ce protocole
est de mettre en lumière les points chauds du programme, c’est-à-dire les
parties du code qui ralentissent considérablement l’exécution de la simulation.
Ces points chauds seront les cibles de nos optimisations. D’autre part, après
chaque tentative d’optimisation, le protocole doit nous permettre de mesurer
l’impact de cette dernière, qu’il soit positif ou négatif, et enfin de le
quantifier.

\subsection{Théorie}
\label{sub.prot.theo}

Le protocole se doit d’être le plus représentatif possible d’une utilisation
typique du programme. Pour cela, on ne doit pas uniquement mesurer la simulation
exécutant une fonctionnalité particulière, mais l’ensemble des fonctionnalités.
Il est bon de noter que ceci est vrai dans le cas d’un unique protocole, comme
ici : en effet, on pourrait imaginer plusieurs protocoles différents pour
optimiser chaque fonctionnalité indépendamment des autres. Ici, le programme
nous offre deux fonctionnalités : ajouter de la fumée dans un espace confiné et
ajouter une vélocité (c’est-à-dire un vecteur vitesse) modifiant ainsi la
trajectoire de la fumée. Notre protocole doit donc faire intervenir ces deux
possibilités dans notre expérience.

Lors de nos expériences, il ne faut pas oublier que le hasard ou l’aléa des
mesures peuvent biaiser un résultat. Afin d’éviter cela, il faut donc utiliser
une valeur moyenne ou une valeur médiane.

\subsection{Pratique}
\label{sub.prot.pract}

Pour effectuer nos mesures, il nous faut utiliser un outil de d’analyse de
performance. Plusieurs possibilités s’offrent à nous, parmi lesquels nous
pouvons notamment citer : Performance Counters for Linux (perf), OProfile,
Gprof, MAQAO, Callgrind/Kcachegrind, et bien d’autre. Parmi ces choix-là, nous
avons choisis d’utiliser \enquote{perf}. Nous pouvons lui citer plusieurs
avantages qui nous ont intéressés : intégration en ligne de commande, outil
bas-niveau, développement stable, accès aux compteurs hardware. Nous pouvons
donc en déduire que c’est un outil tout à fait adapter à l’analyse de code
bas-niveau (C, assembleur).

Le programme de simulation utilise une interface graphique pour rentrer en
interaction avec l’utilisateur. De ce fait, nous ne pouvons pas lui donner un
jeu de données défini à l’avance qui serais constant entre les différentes
mesures. Nous devons alors définir des actions à réaliser de la manière la plus
similaire possible entre les exécutions. De manière \enquote{arbitraire}, nous
définissions un run de la manière suivante : une fois l’applet lancé, nous
traçons une ligne de fumée en diagonale, du point en bas à droite au point en
haut à gauche [clic gauche enfoncé], puis nous refaisons la même opération en
appliquant une vélocité sur ce trajet [clic droit enfoncé], dans le même sens.

Cependant, même en appliquant les mêmes actions entre chaque expérience, les
temps d’exécution seront irrémédiablement différents. Dès lors, pour mesurer la
performance d’une fonction, nous n’allons pas regarder le nombre de cycles
passés dans cette fonction mais son pourcentage de cycle par rapport à
l’ensemble du programme. En effet, étant donné que le pourcentage est un rapport
sur le temps de l’ensemble du programme, ce dernier peux varier tout en gardant
un pourcentage similaire pour une même fonction, car le nombre de cycles passé
dans cette fonction augmentera proportionnellement.

Pendant nos expériences, nous choisirons une grille de 225x225 car c’est le
premier seuil où l’application devient trop lente pour être utilisée sur notre
machine de test. Cela nous permettre de mieux nous rendre compte de nos
optimisations.

Lors de nos mesures préliminaires, on observe au maximum un écart de $\pm 5 \%$
entre les différentes mesures successives. Nous choisissons donc, pour chaque
résultat, d’effectuer 5 tests et de prendre la valeur médiane : cela nous semble
suffisant.

\section{Optimisations et mesures}
\label{sec.optim}

Le compilateur utilisé pour ce projet est \ac{GCC} v8.2.0. La mise en place de
la compilation consiste à déterminer les bons flags de compilation sur lesquels
nous allons partir pour optimiser notre code. Nous ajoutons tout d’abord
\enquote{-g3} afin d’inclure dans le binaire les symboles et informations sur le
code source. Nous nous assurons que ce flag n’as pas d’incidence sur les
performances. Ci-dessous les résultats des analyses du projet au départ, avec
\ac{GCC} :

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.62]{figures/optims/gcc-O0/global.png}
    \caption{Profilage global avec \ac{GCC} en \enquote{-O0}}
    \label{fig.optim.global}
\end{figure}

Comme nous pouvions l’imaginer, la Figure~\ref{fig.optim.global} nous confirme
que les fonctions les plus chaudes sont \enquote{linearSolver()} et
\enquote{build\_index()}, la première de par sa nature de calcul intensif, la
deuxième du fait qu’elle soit appelée énormément de fois. On remarque que toutes
les autres fonctions sont d’une importance mineure dans le temps d’exécution du
programme : inférieure à $3\%$ pour la plus chaude. À elle seule, la fonction
\enquote{linearSolver()} prend presque $50\%$ du temps d’exécution du
programme : c’est la plus importante.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.6]{figures/optims/gcc-O0/linearSolver-others.png}
    \\ \phantom{ } \\
    \includegraphics[scale=0.5]{figures/optims/gcc-O0/linearSolver-div.png}
    \caption{Profilage de \enquote{linearSolver()} avec \ac{GCC} en \enquote{-O0}}
    \label{fig.optim.linearSolver}
\end{figure}

La Figure~\ref{fig.optim.linearSolver} nous permet d'analyser quelles
instructions de la fonction \enquote{linearSolver()} ont un impact important sur
le temps d’exécution. La première image nous montre un lot successif
d’instructions prenant chacune 1 à 4\% du temps d’exécution : des \textit{add},
\textit{mul}, \textit{mov}, \textit{lea}. La deuxième image met en évidence une
instruction \textit{div} qui prends à elle seule $16\%$ du temps de la fonction.
On identifie donc parfaitement les deux sources de ralentissement de la
fonction : la première étant un trop grand nombre d’instructions pour effectuer
les calculs et la seconde étant la division.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.40]{figures/optims/gcc-O0/build_index.png}
    \\ \phantom{ } \\
    \includegraphics[scale=0.55]{figures/optims/gcc-O0/build_index@plt.png}
    \caption{Profilage de \enquote{build\_index()} et \enquote{build\_index()@plt} avec \ac{GCC} en \enquote{-O0}}
    \label{fig.optim.build_index}
\end{figure}

Le temps passé dans la fonction \enquote{build\_index()} est divisé
équitablement en \textit{mov}/\textit{add} d'après la
Figure~\ref{fig.optim.build_index}, permettant de faire les deux additions et la
multiplication que doit faire la fonction. On remarque tout de même que $32\%$
du temps de la fonction est passé dans la mise en place de la stack frame de la
fonction (2 premières instructions \textit{mov}). Enfin, on remarquera que $7\%$
du temps de la simulation est passée dans la fonction \enquote{build\_index@plt}.
Pour comprendre d’où vient cette fonction, il faut revenir sur les bases du
fonctionnement du chargement dynamique de code. Afin d’avoir des bibliothèques
partagées qui puissent être chargées qu’une seule fois en mémoire mais à des
emplacements indépendants pour deux processus différents, on utilise un
mécanisme de code à position indépendante (\ac{PIC}). Ce système fait recours à
une \ac{GOT} contenant les adresses des variables et fonctions dont
l’emplacement n’est pas connu au moment de la compilation. Cette \ac{GOT} est
consultée par les fonctions contenues dans la \ac{PLT}, une table contenant des
fonctions \textit{stubs} (wrapper) qui sont appelées à la place de la vraie
fonction. Cette fonction stub (@plt) permet d’aller consulter la \ac{GOT}, de
remplir la \ac{GOT} lors du premier appel (\textit{lazy loader}), enfin
d’exécuter la vraie fonction. Toutes les prochaines fois ou la fonction stub
sera appelée, alors on va directement chargé l’adresse contenu dans la
\textit{GOT} pour appeler la fonction désirée.

\subsection{Mise en place de la compilation}
\label{sub.optim.compil}

Premièrement, nous avons testé les flags suivants activant des options de lot
d’optimisation : \enquote{-O1}, \enquote{-O2}, \enquote{-O3} (agressivité au
détriment de la taille du code généré), \enquote{-Os} (optimisation de la taille
du code). L’utilisation d’un de ces flags nous apporte une légère amélioration
de fluidité visuelle, cependant il se trouve que nous n’avons pas observé de
différence majeure entre ces 4 différentes flags, que ce soit en termes de code
généré ou de performances et répartition du temps entre les fonctions.
Ci-dessous les images des résultats avec \ac{GCC} et \enquote{-O2} :
% TODO

Nous avons aussi testé les performances du programme avec
\enquote{Clang/\ac{LLVM}}, et les flags d’optimisation les plus agressifs
(\enquote{-03}). Ci-dessous les images des résultats avec Clang et \enquote{-O3}
:
% TODO

Nous observons donc un net gain à utiliser Clang par rapport à \ac{GCC}.
Cependant, pour nous permettre d’appliquer des optimisations vu en cours à la
main, nous allons opter pour la version que produit \ac{GCC} comme base de
travail.

\subsection{Inlining}
\label{sub.optim.inlin}

TODO

\subsection{Déroulage de boucle}
\label{sub.optim.unrol}

TODO

\subsection{Vectorisation}
\label{sub.optim.vec}

TODO

\section{Conclusion}
\label{sec.conc}

TODO

\newpage
\section*{Acronymes}
\label{sec.acro}

\begin{acronym}
    \acro{GCC}  {GNU Compiler Collection}
    \acro{LLVM} {Low Level Virtual Machine}
    \acro{PIC}  {Position-Independent Code}
    \acro{GOT}  {Global Offset Table}
    \acro{PLT}  {Procedure Linkage Table}
\end{acronym}

\end{document}
